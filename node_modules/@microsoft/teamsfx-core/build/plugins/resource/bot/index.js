"use strict";
var TeamsBot_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TeamsBot = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const result_1 = require("./result");
const plugin_1 = require("./plugin");
const progressBars_1 = require("./progressBars");
const constants_1 = require("./constants");
const errors_1 = require("./errors");
const logger_1 = require("./logger");
const telemetry_helper_1 = require("./utils/telemetry-helper");
const question_1 = require("../../solution/fx-solution/question");
const typedi_1 = require("typedi");
const ResourcePluginContainer_1 = require("../../solution/fx-solution/ResourcePluginContainer");
require("./v2");
require("./v3");
const plugin_2 = require("./dotnet/plugin");
const common_1 = require("../../../common");
const plugin_3 = require("./functionsHostedBot/plugin");
const scaffoldConfig_1 = require("./configs/scaffoldConfig");
const question_2 = require("./question");
const localizeUtils_1 = require("../../../common/localizeUtils");
let TeamsBot = TeamsBot_1 = class TeamsBot {
    constructor() {
        this.name = "fx-resource-bot";
        this.displayName = "Bot";
        this.teamsBotImpl = new plugin_1.TeamsBotImpl();
        this.dotnetBotImpl = new plugin_2.DotnetBotImpl();
        this.functionsBotImpl = new plugin_3.FunctionsHostedBotImpl();
    }
    activate(solutionSettings) {
        const cap = solutionSettings.capabilities || [];
        return cap.includes(question_1.BotOptionItem.id) || cap.includes(question_1.MessageExtensionItem.id);
    }
    /**
     * @param isScaffold true for `scaffold` lifecycle, false otherwise.
     */
    getImpl(context, isScaffold = false) {
        if (common_1.isVSProject(context.projectSettings)) {
            return this.dotnetBotImpl;
        }
        else if (TeamsBot_1.isFunctionsHostedBot(context, isScaffold)) {
            return this.functionsBotImpl;
        }
        else {
            return this.teamsBotImpl;
        }
    }
    async scaffold(context) {
        logger_1.Logger.setLogger(context.logProvider);
        const result = await TeamsBot_1.runWithExceptionCatching(context, () => this.getImpl(context, true).scaffold(context), true, constants_1.LifecycleFuncNames.SCAFFOLD);
        await progressBars_1.ProgressBarFactory.closeProgressBar(result.isOk(), constants_1.ProgressBarConstants.SCAFFOLD_TITLE);
        return result;
    }
    async preProvision(context) {
        logger_1.Logger.setLogger(context.logProvider);
        return await TeamsBot_1.runWithExceptionCatching(context, () => this.getImpl(context).preProvision(context), true, constants_1.LifecycleFuncNames.PRE_PROVISION);
    }
    async provision(context) {
        logger_1.Logger.setLogger(context.logProvider);
        const result = await TeamsBot_1.runWithExceptionCatching(context, () => this.getImpl(context).provision(context), true, constants_1.LifecycleFuncNames.PROVISION);
        await progressBars_1.ProgressBarFactory.closeProgressBar(result.isOk(), constants_1.ProgressBarConstants.PROVISION_TITLE);
        return result;
    }
    async postProvision(context) {
        logger_1.Logger.setLogger(context.logProvider);
        return await TeamsBot_1.runWithExceptionCatching(context, () => this.getImpl(context).postProvision(context), true, constants_1.LifecycleFuncNames.POST_PROVISION);
    }
    async updateArmTemplates(context) {
        logger_1.Logger.setLogger(context.logProvider);
        return await TeamsBot_1.runWithExceptionCatching(context, () => this.getImpl(context).updateArmTemplates(context), true, constants_1.LifecycleFuncNames.GENERATE_ARM_TEMPLATES);
    }
    async generateArmTemplates(context) {
        logger_1.Logger.setLogger(context.logProvider);
        return await TeamsBot_1.runWithExceptionCatching(context, () => this.getImpl(context).generateArmTemplates(context), true, constants_1.LifecycleFuncNames.GENERATE_ARM_TEMPLATES);
    }
    async preDeploy(context) {
        logger_1.Logger.setLogger(context.logProvider);
        return await TeamsBot_1.runWithExceptionCatching(context, () => this.getImpl(context).preDeploy(context), true, constants_1.LifecycleFuncNames.PRE_DEPLOY);
    }
    async deploy(context) {
        logger_1.Logger.setLogger(context.logProvider);
        const result = await TeamsBot_1.runWithExceptionCatching(context, () => this.getImpl(context).deploy(context), true, constants_1.LifecycleFuncNames.DEPLOY);
        await progressBars_1.ProgressBarFactory.closeProgressBar(result.isOk(), constants_1.ProgressBarConstants.DEPLOY_TITLE);
        return result;
    }
    async localDebug(context) {
        logger_1.Logger.setLogger(context.logProvider);
        const result = await TeamsBot_1.runWithExceptionCatching(context, () => this.getImpl(context).localDebug(context), false, constants_1.LifecycleFuncNames.LOCAL_DEBUG);
        await progressBars_1.ProgressBarFactory.closeProgressBar(result.isOk(), constants_1.ProgressBarConstants.LOCAL_DEBUG_TITLE);
        return result;
    }
    async postLocalDebug(context) {
        logger_1.Logger.setLogger(context.logProvider);
        return await TeamsBot_1.runWithExceptionCatching(context, () => this.getImpl(context).postLocalDebug(context), false, constants_1.LifecycleFuncNames.POST_LOCAL_DEBUG);
    }
    async getQuestions(stage, context) {
        logger_1.Logger.setLogger(context.logProvider);
        if (stage === teamsfx_api_1.Stage.create) {
            return await TeamsBot_1.runWithExceptionCatching(context, async () => {
                var _a;
                if (common_1.isBotNotificationEnabled()) {
                    const res = new teamsfx_api_1.QTreeNode({
                        type: "group",
                    });
                    res.addChild(new teamsfx_api_1.QTreeNode(question_2.createHostTypeTriggerQuestion((_a = context.answers) === null || _a === void 0 ? void 0 : _a.platform)));
                    res.condition = question_2.showNotificationTriggerCondition;
                    return teamsfx_api_1.ok(res);
                }
                else {
                    return teamsfx_api_1.ok(undefined);
                }
            }, true, constants_1.LifecycleFuncNames.GET_QUETSIONS_FOR_SCAFFOLDING);
        }
        else {
            return teamsfx_api_1.ok(undefined);
        }
    }
    async getQuestionsForUserTask(func, context) {
        logger_1.Logger.setLogger(context.logProvider);
        return await TeamsBot_1.runWithExceptionCatching(context, async () => {
            var _a;
            if (func.method === constants_1.CustomizedTasks.addCapability && common_1.isBotNotificationEnabled()) {
                const res = new teamsfx_api_1.QTreeNode({
                    type: "group",
                });
                res.addChild(new teamsfx_api_1.QTreeNode(question_2.createHostTypeTriggerQuestion((_a = context.answers) === null || _a === void 0 ? void 0 : _a.platform)));
                res.condition = question_2.showNotificationTriggerCondition;
                return teamsfx_api_1.ok(res);
            }
            else {
                return teamsfx_api_1.ok(undefined);
            }
        }, true, constants_1.LifecycleFuncNames.GET_QUETSIONS_FOR_USER_TASK);
    }
    static wrapError(e, context, sendTelemetry, name) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        let errorMsg = errors_1.isErrorWithMessage(e) ? e.message : "";
        const innerError = errors_1.isPluginError(e) ? e.innerError : undefined;
        if (innerError) {
            errorMsg += localizeUtils_1.getLocalizedString("plugins.bot.DetailedError", errors_1.isErrorWithMessage(innerError) ? innerError.message : "");
            if (errors_1.isHttpError(innerError)) {
                if ((_b = (_a = innerError.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.errorMessage) {
                    errorMsg += localizeUtils_1.getLocalizedString("plugins.bot.DetailedErrorReason", (_d = (_c = innerError.response) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d.errorMessage);
                }
                else if ((_g = (_f = (_e = innerError.response) === null || _e === void 0 ? void 0 : _e.data) === null || _f === void 0 ? void 0 : _f.error) === null || _g === void 0 ? void 0 : _g.message) {
                    // For errors return from Graph API
                    errorMsg += localizeUtils_1.getLocalizedString("plugins.bot.DetailedErrorReason", (_k = (_j = (_h = innerError.response) === null || _h === void 0 ? void 0 : _h.data) === null || _j === void 0 ? void 0 : _j.error) === null || _k === void 0 ? void 0 : _k.message);
                }
            }
        }
        logger_1.Logger.error(errorMsg);
        if (e instanceof teamsfx_api_1.UserError || e instanceof teamsfx_api_1.SystemError) {
            const res = teamsfx_api_1.err(e);
            sendTelemetry && telemetry_helper_1.telemetryHelper.sendResultEvent(context, name, res);
            return res;
        }
        if (e instanceof errors_1.PluginError) {
            const result = e.errorType === errors_1.ErrorType.SYSTEM
                ? result_1.FxBotPluginResultFactory.SystemError(e.name, [e.genMessage(), e.genDisplayMessage()], e.innerError)
                : result_1.FxBotPluginResultFactory.UserError(e.name, [e.genMessage(), e.genDisplayMessage()], e.innerError, e.helpLink);
            sendTelemetry && telemetry_helper_1.telemetryHelper.sendResultEvent(context, name, result);
            return result;
        }
        else {
            // Unrecognized Exception.
            const UnhandledErrorCode = "UnhandledError";
            sendTelemetry &&
                telemetry_helper_1.telemetryHelper.sendResultEvent(context, name, result_1.FxBotPluginResultFactory.SystemError(UnhandledErrorCode, [
                    localizeUtils_1.getDefaultString("plugins.bot.UnhandledError", errorMsg),
                    localizeUtils_1.getLocalizedString("plugins.bot.UnhandledError", errorMsg),
                ], errors_1.isPluginError(e) ? e.innerError : undefined));
            return result_1.FxBotPluginResultFactory.SystemError(UnhandledErrorCode, [errorMsg, errorMsg], innerError);
        }
    }
    static async runWithExceptionCatching(context, fn, sendTelemetry, name) {
        try {
            sendTelemetry && telemetry_helper_1.telemetryHelper.sendStartEvent(context, name);
            const res = await fn();
            sendTelemetry && telemetry_helper_1.telemetryHelper.sendResultEvent(context, name, res);
            return res;
        }
        catch (e) {
            await progressBars_1.ProgressBarFactory.closeProgressBar(false); // Close all progress bars.
            return TeamsBot_1.wrapError(e, context, sendTelemetry, name);
        }
    }
    static isFunctionsHostedBot(context, isScaffold) {
        return scaffoldConfig_1.ScaffoldConfig.getBotHostType(context, isScaffold) === common_1.BotHostTypes.AzureFunctions;
    }
};
TeamsBot = TeamsBot_1 = tslib_1.__decorate([
    typedi_1.Service(ResourcePluginContainer_1.ResourcePlugins.BotPlugin)
], TeamsBot);
exports.TeamsBot = TeamsBot;
exports.default = new TeamsBot();
//# sourceMappingURL=index.js.map